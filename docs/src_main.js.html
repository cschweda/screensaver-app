<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: src/main.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-modules"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-compress-images.html">compress-images</a></div><div class="sidebar-section-children"><a href="module-config.html">config</a></div><div class="sidebar-section-children"><a href="module-config.html">config</a></div><div class="sidebar-section-children"><a href="module-download-sample-images.html">download-sample-images</a></div><div class="sidebar-section-children"><a href="module-main.html">main</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-namespaces"><div>Namespaces</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-config-config.display.html">display</a></div><div class="sidebar-section-children"><a href="module-config-config.images.html">images</a></div><div class="sidebar-section-children"><a href="module-config-config.placeholders.html">placeholders</a></div><div class="sidebar-section-children"><a href="module-config-config.ui.html">ui</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">src_main.js</h1></header><article><pre class="prettyprint source lang-js"><code>/**
 * @fileoverview Web Photo Screensaver Application
 *
 * A browser-based photo screensaver that displays images in fullscreen mode with smooth transitions.
 * Supports custom images, configurable display duration, and keyboard navigation.
 * Features include image selection, randomization, background color customization, and more.
 *
 * @module main
 * @author Chris Schweda
 * @version 1.0.0
 * @requires module:config
 * @requires module:style.css
 */

import './style.css';
import config from './config.js';

/**
 * Loading Overlay Management
 * Handles the loading overlay to prevent Flash of Unstyled Content (FOUC)
 */
const loadingOverlay = document.getElementById('loading-overlay');
const mainContent = document.getElementById('main-content');

/**
 * Hides the loading overlay and shows the main content
 * @function hideLoadingOverlay
 * @returns {void}
 */
function hideLoadingOverlay() {
    // Fade out the loading overlay
    loadingOverlay.style.opacity = '0';

    // Show the main content
    mainContent.classList.remove('content-hidden');
    mainContent.style.opacity = '1';

    // Remove the overlay from the DOM after the transition
    setTimeout(() => {
        loadingOverlay.style.display = 'none';
    }, 500); // Match the transition duration in CSS
}

/**
 * Applies configuration values to the DOM
 * @function applyConfigToDOM
 * @returns {void}
 */
function applyConfigToDOM() {
    // Set the thumbnail size CSS variable
    document.documentElement.style.setProperty('--thumbnail-size', `${config.ui.thumbnailSize}px`);
}

/**
 * DOM Elements
 * Collection of DOM element references
 * @type {Object}
 */
const thumbnailContainer = document.getElementById('thumbnail-container');
const thumbnailLoading = document.getElementById('thumbnail-loading');
const selectAllButton = document.getElementById('select-all-button');
const deselectAllButton = document.getElementById('deselect-all-button');
const emptyFolderWarning = document.getElementById('empty-folder-warning');
const durationInput = document.getElementById('duration-input');
const randomizeCheckbox = document.getElementById('randomize-checkbox');
const startButton = document.getElementById('start-button');
const fullscreenContainer = document.getElementById('fullscreen-container');
const imageDisplay = document.getElementById('image-display');
const imageInfo = document.getElementById('image-info');
const cornerMenu = document.getElementById('corner-menu');
const exitButton = document.getElementById('exit-button');
const restartButton = document.getElementById('restart-button');
const cornerZones = document.querySelectorAll('.corner-zone');
const bgColorInput = document.getElementById('bg-color-input');
const messageBox = document.getElementById('message-box');
// Container for fullscreen elements - used in multiple functions for DOM manipulation
// This variable is used in displayImage() function for adding/removing CSS classes and DOM manipulation
// The IDE may show a warning that it's unused, but it is actually used in the code
const fullscreenElements = document.getElementById('fullscreen-elements');
const loadingIndicator = document.getElementById('loading-indicator');

/**
 * State Variables
 */
/** Array to hold images from the images folder
 * @type {Object[]} */
let folderImages = [];
/** Array to hold selected images for the slideshow
 * @type {Object[]} */
let selectedImages = [];
/** Array to hold the order of images to display
 * @type {number[]} */
let displayOrder = [];
/** Current index in the display order array
 * @type {number} */
let currentOrderIndex = 0;
/** Current index in the image array being displayed
 * @type {number} */
let currentImageIndex = 0;
/** Interval ID for the slideshow
 * @type {number|null} */
let slideshowInterval;
/** Default duration in milliseconds between image transitions
 * @type {number} */
let displayDuration = 5000;
/** Timeout ID for hiding the menu
 * @type {number|null} */
let menuTimeout;
/** Flag to track if images should be displayed in random order
 * @type {boolean} */
let randomizeOrder = false;
/** Cache for preloaded images
 * @type {Object.&lt;string, boolean>} */
let preloadedImages = {};

/**
 * Utility Functions
 */

/**
 * Displays a temporary message to the user
 * @function showMessage
 * @param {string} message - The message to display
 * @param {number} [duration=config.ui.messageDisplayDuration] - How long to show the message in milliseconds
 * @returns {void}
 */
function showMessage(message, duration = config.ui.messageDisplayDuration) {
    messageBox.textContent = message;
    messageBox.style.display = 'block';
    setTimeout(() => {
        messageBox.style.display = 'none';
    }, duration);
}

/**
 * Compresses an image if it's larger than the specified size
 * This function is kept for reference but is not currently used.
 * Image compression is now handled by the server-side script.
 *
 * @function compressImageIfNeeded
 * @async
 * @param {string} imageUrl - The URL of the image to compress
 * @param {string} imageName - The name of the image
 * @param {number} [maxSizeInMB=1] - Maximum size in MB before compression
 * @returns {Promise&lt;Object>} - Object containing the compressed image URL and metadata
 * @deprecated - Use server-side compression instead
 */
async function compressImageIfNeeded(imageUrl, imageName, maxSizeInMB = 1) {
    try {
        // Fetch the image to check its size
        const response = await fetch(imageUrl);
        const blob = await response.blob();
        const originalSizeInMB = blob.size / (1024 * 1024);

        // If the image is smaller than the max size, return the original
        if (originalSizeInMB &lt;= maxSizeInMB) {
            return {
                url: imageUrl,
                name: imageName,
                size: originalSizeInMB.toFixed(2),
                compressed: false
            };
        }

        // Create an image element to load the image
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                // Create a canvas to compress the image
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                // Calculate the new dimensions while maintaining aspect ratio
                // For large images, we'll reduce the dimensions to improve compression
                let width = img.width;
                let height = img.height;

                // Scale down very large images more aggressively
                const scaleFactor = originalSizeInMB > 5 ? 0.5 : 0.7;

                width = Math.floor(width * scaleFactor);
                height = Math.floor(height * scaleFactor);

                // Set canvas dimensions
                canvas.width = width;
                canvas.height = height;

                // Draw the image on the canvas with the new dimensions
                ctx.drawImage(img, 0, 0, width, height);

                // Convert the canvas to a Blob with reduced quality
                const quality = originalSizeInMB > 5 ? 0.6 : 0.8;

                canvas.toBlob((compressedBlob) => {
                    if (!compressedBlob) {
                        reject(new Error('Failed to compress image'));
                        return;
                    }

                    // Create a URL for the compressed blob
                    const compressedUrl = URL.createObjectURL(compressedBlob);
                    const compressedSizeInMB = compressedBlob.size / (1024 * 1024);

                    // Return the compressed image info
                    resolve({
                        url: compressedUrl,
                        name: `${imageName} (compressed)`,
                        originalSize: originalSizeInMB.toFixed(2),
                        size: compressedSizeInMB.toFixed(2),
                        compressed: true,
                        compressionRatio: (originalSizeInMB / compressedSizeInMB).toFixed(1)
                    });
                }, 'image/jpeg', quality);
            };

            img.onerror = () => {
                reject(new Error(`Failed to load image: ${imageName}`));
            };

            img.src = imageUrl;
        });
    } catch (error) {
        console.error('Error compressing image:', error);
        // Return the original image if compression fails
        return {
            url: imageUrl,
            name: imageName,
            compressed: false
        };
    }
}

/**
 * Loads images from the images folder and creates thumbnails
 * First tries to load from the local images directory, then falls back to sample images
 * @function loadImagesFromFolder
 * @async
 * @returns {Promise&lt;boolean>} - True if images were found, false otherwise
 */
async function loadImagesFromFolder() {
    try {
        // Show loading indicator
        thumbnailLoading.style.display = 'flex';

        // Clear the thumbnail container (except the loading indicator)
        Array.from(thumbnailContainer.children).forEach(child => {
            if (child !== thumbnailLoading) {
                child.remove();
            }
        });

        // First try to load images from the public/images directory
        let folderImageFiles = [];

        try {
            // Try to fetch the list of images from the public/images directory
            const response = await fetch('/api/images');
            if (response.ok) {
                folderImageFiles = await response.json();
            }
        } catch (error) {
            console.warn('Could not fetch images from API, using sample images instead:', error);
        }

        // If no images were found in the folder, use sample images
        if (folderImageFiles.length === 0) {
            console.log('No images found in the public/images folder, using sample images');

            // Use sample images from config
            const sampleImages = config.placeholders.sampleImages;

            // Create image objects from sample images
            folderImages = sampleImages.map(img => ({
                url: img.url,
                name: img.name,
                selected: true
            }));
        } else {
            // Create image objects from the files in the public/images directory
            folderImages = folderImageFiles.map(file => ({
                url: `/images/${file}`,
                name: file,
                selected: true
            }));

            console.log(`Found ${folderImages.length} images in the public/images folder`);
        }

        // Hide loading indicator
        thumbnailLoading.style.display = 'none';

        if (folderImages.length === 0) {
            console.log('No images found');
            emptyFolderWarning.classList.remove('hidden');
            // Update the warning message from config
            const warningText = emptyFolderWarning.querySelector('p:last-child');
            if (warningText) {
                warningText.textContent = config.ui.emptyFolderWarning;
            }
            startButton.disabled = true;
            return false;
        }

        // Hide the warning if we have images
        emptyFolderWarning.classList.add('hidden');

        // Sort images by name for consistent display
        folderImages.sort((a, b) => a.name.localeCompare(b.name));

        // Create thumbnails for each image
        folderImages.forEach((image, index) => {
            createThumbnail(image, index);
        });

        // Update the selected images array
        updateSelectedImages();

        console.log(`Found ${folderImages.length} images in the images folder`);
        return true;
    } catch (error) {
        console.error('Error loading images from folder:', error);
        // Hide loading indicator
        thumbnailLoading.style.display = 'none';
        emptyFolderWarning.classList.remove('hidden');
        startButton.disabled = true;
        return false;
    }
}

/**
 * Creates a thumbnail element for an image
 * @function createThumbnail
 * @param {Object} image - The image object
 * @param {string} image.url - The URL of the image
 * @param {string} image.name - The name of the image
 * @param {boolean} image.selected - Whether the image is selected
 * @param {number} index - The index of the image in the folderImages array
 * @returns {void}
 */
function createThumbnail(image, index) {
    // Create the thumbnail container
    const thumbnailItem = document.createElement('div');
    thumbnailItem.className = 'thumbnail-item' + (image.selected ? ' selected' : '');
    thumbnailItem.dataset.index = index;

    // Create a container for the image and loading spinner
    const imageContainer = document.createElement('div');
    imageContainer.className = 'thumbnail-image-container';

    // Create the loading spinner
    const spinner = document.createElement('div');
    spinner.className = 'thumbnail-spinner';
    spinner.innerHTML = `
        &lt;div class="spinner-border" role="status">
            &lt;div class="spinner-circle">&lt;/div>
        &lt;/div>
    `;

    // Create the image element
    const img = document.createElement('img');
    img.className = 'thumbnail-image';
    img.alt = image.name;
    img.loading = 'lazy'; // Lazy load images for better performance

    // Add load event to hide spinner when image loads
    img.onload = () => {
        spinner.style.display = 'none';
        img.style.opacity = '1';
    };

    // Add error handling for images
    img.onerror = () => {
        // If image fails to load, show a placeholder and hide spinner
        spinner.style.display = 'none';
        img.style.opacity = '1';
        img.src = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='150' height='150' viewBox='0 0 150 150'%3E%3Crect width='150' height='150' fill='%23374151'/%3E%3Ctext x='75' y='75' font-family='Arial' font-size='14' fill='white' text-anchor='middle' dominant-baseline='middle'%3E${image.name}%3C/text%3E%3C/svg%3E`;
    };

    // Set the image source after setting up events
    img.src = image.url;

    // Create the checkbox
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.className = 'thumbnail-checkbox';
    checkbox.checked = image.selected;
    checkbox.addEventListener('change', (e) => {
        // Update the selected state
        folderImages[index].selected = e.target.checked;
        thumbnailItem.classList.toggle('selected', e.target.checked);

        // Update the selected images array
        updateSelectedImages();
    });

    // Create the image name label
    const nameLabel = document.createElement('div');
    nameLabel.className = 'thumbnail-name';
    nameLabel.textContent = image.name;

    // Add click event to the thumbnail (excluding the checkbox)
    thumbnailItem.addEventListener('click', (e) => {
        // Only toggle if the click wasn't on the checkbox
        if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
            // Trigger the change event
            checkbox.dispatchEvent(new Event('change'));
        }
    });

    // Append elements to the image container
    imageContainer.appendChild(img);
    imageContainer.appendChild(spinner);

    // Append elements to the thumbnail
    thumbnailItem.appendChild(imageContainer);
    thumbnailItem.appendChild(checkbox);
    thumbnailItem.appendChild(nameLabel);

    // Add the thumbnail to the container
    thumbnailContainer.appendChild(thumbnailItem);
}

/**
 * Updates the selectedImages array based on the selected state of folderImages
 * @function updateSelectedImages
 * @returns {void}
 */
function updateSelectedImages() {
    selectedImages = folderImages.filter(image => image.selected);
    // Update the start button text whenever selected images change
    updateStartButtonText();
}

/**
 * Updates the start button text with the current number of selected images
 * @function updateStartButtonText
 * @returns {void}
 */
function updateStartButtonText() {
    startButton.textContent = `Start Screensaver (${selectedImages.length} photos)`;
    startButton.disabled = selectedImages.length === 0;
}

/**
 * Gets the current list of images to display
 * @function getCurrentImageList
 * @returns {Object[]} - The list of selected images
 */
function getCurrentImageList() {
    return selectedImages;
}

/**
 * Generates the display order for images based on randomization setting
 * @param {number} length - The number of images
 * @returns {number[]} - Array of indices representing the display order
 */
function generateDisplayOrder(length) {
    if (length === 0) return [];

    // Create an array of indices [0, 1, 2, ..., length-1]
    const order = Array.from({ length }, (_, i) => i);

    // If randomize is enabled, shuffle the array
    if (randomizeOrder) {
        // Fisher-Yates shuffle algorithm
        for (let i = order.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [order[i], order[j]] = [order[j], order[i]]; // Swap elements
        }
    }

    return order;
}

/**
 * Gets the URL for an image at the specified index
 * @param {number} index - The index of the image
 * @returns {string} - The URL of the image
 */
function getImageUrl(index) {
    if (index &lt; 0 || index >= selectedImages.length) return '';
    return selectedImages[index].url;
}

/**
 * Gets the name for an image at the specified index
 * @param {number} index - The index of the image
 * @returns {string} - The name of the image
 */
function getImageName(index) {
    if (index &lt; 0 || index >= selectedImages.length) return '';
    return selectedImages[index].name;
}

/**
 * Preloads images for smoother transitions
 * @param {number} startIndex - The index to start preloading from
 * @param {number} [count=3] - How many images to preload
 */
function preloadImages(startIndex, count = 3) {
    if (selectedImages.length === 0) return;

    for (let i = 0; i &lt; count; i++) {
        const index = (startIndex + i) % selectedImages.length;
        const imageUrl = getImageUrl(index);

        // Skip if already preloaded
        if (preloadedImages[imageUrl]) continue;

        // Create new image for preloading
        const img = new Image();
        img.onload = () => {
            preloadedImages[imageUrl] = true;
            console.log(`Preloaded image: ${imageUrl}`);
        };
        img.onerror = () => {
            console.error(`Failed to preload image: ${imageUrl}`);
        };
        img.src = imageUrl;
    }
}

/**
 * Event Listeners
 *
 * Note: The fullscreenElements variable is used in multiple places:
 * - In the displayImage function for adding/removing CSS classes
 * - In the displayImage function for appending the next image element
 * - In the handleFullscreenChange function indirectly through DOM manipulation
 */

// Handle select all button click
selectAllButton.addEventListener('click', () => {
    // Update all images to be selected
    folderImages.forEach((image, index) => {
        image.selected = true;

        // Update the UI
        const thumbnailItem = thumbnailContainer.querySelector(`.thumbnail-item[data-index="${index}"]`);
        if (thumbnailItem) {
            thumbnailItem.classList.add('selected');
            const checkbox = thumbnailItem.querySelector('.thumbnail-checkbox');
            if (checkbox) checkbox.checked = true;
        }
    });

    // Update the selected images array
    updateSelectedImages();

    showMessage("All photos selected.");
});

// Handle deselect all button click
deselectAllButton.addEventListener('click', () => {
    // Update all images to be deselected
    folderImages.forEach((image, index) => {
        image.selected = false;

        // Update the UI
        const thumbnailItem = thumbnailContainer.querySelector(`.thumbnail-item[data-index="${index}"]`);
        if (thumbnailItem) {
            thumbnailItem.classList.remove('selected');
            const checkbox = thumbnailItem.querySelector('.thumbnail-checkbox');
            if (checkbox) checkbox.checked = false;
        }
    });

    // Update the selected images array
    updateSelectedImages();

    showMessage("All photos deselected.");
});

// Handle randomize checkbox change
randomizeCheckbox.addEventListener('change', (event) => {
    randomizeOrder = event.target.checked;
    if (randomizeOrder) {
        showMessage("Photos will be displayed in random order.");
    } else {
        showMessage("Photos will be displayed in sequential order.");
    }

    // If slideshow is running, regenerate the display order
    if (slideshowInterval) {
        displayOrder = generateDisplayOrder(selectedImages.length);
        // Keep the current image but reset the order index to match
        currentOrderIndex = displayOrder.indexOf(currentImageIndex);
        if (currentOrderIndex === -1) currentOrderIndex = 0; // Fallback if not found
    }
});

// Handle duration change
durationInput.addEventListener('change', () => {
    const seconds = parseInt(durationInput.value, 10);
    if (seconds >= 1) {
        displayDuration = seconds * 1000;
        // If slideshow is running, restart it with the new duration
        if (slideshowInterval) {
            stopSlideshow();
            startSlideshow();
        }
    } else {
        durationInput.value = displayDuration / 1000; // Reset to previous valid value
        showMessage("Duration must be at least 1 second.", 4000);
    }
});

// Handle background color change
bgColorInput.addEventListener('input', (event) => {
    const color = event.target.value;
    fullscreenContainer.style.setProperty('--bg-color', color);
});

// Handle Start Button click
startButton.addEventListener('click', () => {
    const imageList = getCurrentImageList();
    if (imageList.length > 0) {
        requestFullscreen(); // Attempt to go fullscreen
    } else {
        showMessage("No images available to display.", 4000);
    }
});

// Handle Exit Button click
exitButton.addEventListener('click', () => {
    exitFullscreen();
});

// Handle Restart Button click
restartButton.addEventListener('click', () => {
    currentImageIndex = 0;
    stopSlideshow(); // Stop current cycle
    const imageList = getCurrentImageList();
    if (imageList.length > 0) {
        displayImage(currentImageIndex); // Show first image immediately (already in fullscreen)
        startSlideshow(); // Start new cycle
    }
    hideMenu(); // Hide menu after action
});

// Handle fullscreen change events (browser exit, e.g., Esc key)
document.addEventListener('fullscreenchange', handleFullscreenChange);
document.addEventListener('webkitfullscreenchange', handleFullscreenChange); // Safari

// Add keyboard controls for accessibility
document.addEventListener('keydown', (event) => {
    // Only handle keyboard events when in fullscreen
    if (document.fullscreenElement || document.webkitFullscreenElement) {
        switch(event.key) {
            case 'ArrowRight':
            case ' ': // Space bar
                nextImage();
                break;
            case 'ArrowLeft':
                previousImage();
                break;
            case 'Escape': // Already handled by browser for exiting fullscreen
                break;
            case 'm':
            case 'M':
                // Toggle menu
                if (cornerMenu.style.display === 'block') {
                    hideMenu();
                } else {
                    showMenu();
                }
                break;
        }
    }
});

// Handle mouse entering corner zones (only in fullscreen)
cornerZones.forEach(zone => {
    zone.addEventListener('mouseenter', () => {
        if (document.fullscreenElement || document.webkitFullscreenElement) {
            showMenu();
        }
    });
});

// Handle mouse leaving the menu itself
cornerMenu.addEventListener('mouseleave', () => {
    hideMenu();
});

/**
 * Core Logic Functions
 */

/**
 * Displays an image at the specified index
 * @function displayImage
 * @param {number} index - The index of the image to display
 * @returns {void}
 */
function displayImage(index) {
    const imageList = getCurrentImageList();

    if (index >= 0 &amp;&amp; index &lt; imageList.length) {
        const imageUrl = getImageUrl(index);
        const imageName = getImageName(index);

        // Show loading indicator
        loadingIndicator.style.display = 'block';

        // First fade out the current image
        imageDisplay.classList.add('fade-out');
        imageDisplay.classList.remove('fade-in');

        // Create and preload the next image
        const nextImage = new Image();
        nextImage.onload = () => {
            // Hide loading indicator once image is loaded
            loadingIndicator.style.display = 'none';

            // After the fade-out is complete, update the image and fade it back in
            setTimeout(() => {
                // Update the image source and info
                imageDisplay.src = imageUrl;
                imageDisplay.alt = imageName;
                imageInfo.textContent = imageName;

                // Calculate optimal size for the image based on its natural dimensions
                // This will be handled by CSS now with our improved layout

                // Fade the image back in
                imageDisplay.classList.remove('fade-out');
                imageDisplay.classList.add('fade-in');
            }, 250); // Half the transition time for a smoother experience
        };

        nextImage.onerror = () => {
            // Hide loading indicator on error
            loadingIndicator.style.display = 'none';

            console.error("Error loading image:", imageUrl);
            // Use the error image template from config
            const fallbackUrl = config.placeholders.errorImageTemplate.replace('{bgColor}', bgColorInput.value.substring(1));

            // After the fade-out is complete, update with error image
            setTimeout(() => {
                imageDisplay.src = fallbackUrl;
                imageInfo.textContent = `Error loading: ${imageName}`;

                // Fade the image back in
                imageDisplay.classList.remove('fade-out');
                imageDisplay.classList.add('fade-in');
            }, config.display.fadeTransitionDuration);
        };

        nextImage.src = imageUrl;

    } else if (imageList.length === 0) {
        // Hide loading indicator
        loadingIndicator.style.display = 'none';

        // Fade out current image
        imageDisplay.classList.add('fade-out');
        imageDisplay.classList.remove('fade-in');

        setTimeout(() => {
            // Use the no images template from config
            const fallbackUrl = config.placeholders.noImagesTemplate.replace('{bgColor}', bgColorInput.value.substring(1));
            imageDisplay.src = fallbackUrl;
            imageInfo.textContent = '';

            // Fade the image back in
            imageDisplay.classList.remove('fade-out');
            imageDisplay.classList.add('fade-in');
        }, config.display.fadeTransitionDuration);
    }
}


/**
 * Advances to the next image in the slideshow
 * @function nextImage
 * @returns {void}
 */
function nextImage() {
    if (selectedImages.length === 0) return; // Do nothing if no images

    // Move to the next position in the display order
    currentOrderIndex = (currentOrderIndex + 1) % displayOrder.length; // Loop back to 0
    currentImageIndex = displayOrder[currentOrderIndex];
    displayImage(currentImageIndex);

    // Preload the next few images
    const nextOrderIndex = (currentOrderIndex + 1) % displayOrder.length;
    const nextImageIndex = displayOrder[nextOrderIndex];
    preloadImages(nextImageIndex, 3);

    // Reset the slideshow timer to prevent immediate transition
    resetSlideshowTimer();
}

/**
 * Goes to the previous image in the slideshow
 * @function previousImage
 * @returns {void}
 */
function previousImage() {
    if (selectedImages.length === 0) return; // Do nothing if no images

    // Go to previous image in the display order, loop to end if at first image
    currentOrderIndex = (currentOrderIndex - 1 + displayOrder.length) % displayOrder.length;
    currentImageIndex = displayOrder[currentOrderIndex];
    displayImage(currentImageIndex);

    // Preload the previous few images (in case user keeps going back)
    const prevOrderIndex = (currentOrderIndex - 1 + displayOrder.length) % displayOrder.length;
    const prevImageIndex = displayOrder[prevOrderIndex];
    preloadImages(prevImageIndex, 2);

    // Reset the slideshow timer to prevent immediate transition
    resetSlideshowTimer();
}

/**
 * Resets the slideshow timer with a delay to prevent double transitions
 * @function resetSlideshowTimer
 * @returns {void}
 */
function resetSlideshowTimer() {
    // Only reset if slideshow is active
    if (slideshowInterval) {
        // Stop the current slideshow
        stopSlideshow();

        // Wait for the transition to complete before starting a new slideshow
        // This ensures no double-transitions occur
        setTimeout(() => {
            startSlideshow();
        }, 600); // Slightly longer than the transition duration (500ms)
    }
}

/**
 * Starts the slideshow with the current display duration
 * @function startSlideshow
 * @returns {void}
 */
function startSlideshow() {
    // Clear any existing interval first
    stopSlideshow();
    // Only start interval if more than one image
    if (selectedImages.length > 1) {
        slideshowInterval = setInterval(nextImage, displayDuration);
    } else if (selectedImages.length === 1) {
        // If only one image, make sure it's displayed (already handled by handleFullscreenChange)
        // No interval needed
    }
}

/**
 * Stops the slideshow by clearing the interval
 * @function stopSlideshow
 * @returns {void}
 */
function stopSlideshow() {
    clearInterval(slideshowInterval);
    slideshowInterval = null;
}

/**
 * Requests fullscreen mode for the container
 * @function requestFullscreen
 * @returns {void}
 */
function requestFullscreen() {
    // Update duration from input just before starting
    displayDuration = parseInt(durationInput.value, 10) * 1000;
    if (isNaN(displayDuration) || displayDuration &lt; (config.display.minDuration * 1000)) {
        displayDuration = config.display.defaultDuration * 1000; // Fallback
        durationInput.value = config.display.defaultDuration;
    }

    // Update randomize setting
    randomizeOrder = randomizeCheckbox.checked;

    // Update background color
    fullscreenContainer.style.setProperty('--bg-color', bgColorInput.value);

    // Request fullscreen on the container
    console.log("Requesting fullscreen..."); // Debug log
    if (fullscreenContainer.requestFullscreen) {
        fullscreenContainer.requestFullscreen().catch(err => {
            console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            showMessage(`Could not enter fullscreen: ${err.message}`, 5000);
        });
    } else if (fullscreenContainer.webkitRequestFullscreen) { /* Safari */
        fullscreenContainer.webkitRequestFullscreen(); // Note: Safari might not return a promise or support catch easily
    } else if (fullscreenContainer.msRequestFullscreen) { /* IE11 */
        fullscreenContainer.msRequestFullscreen();
    } else {
        console.error("Fullscreen API is not supported by this browser.");
        showMessage("Fullscreen is not supported by your browser.", 5000);
    }
}

/**
 * Exits fullscreen mode
 * @function exitFullscreen
 * @returns {void}
 */
function exitFullscreen() {
    console.log("Exiting fullscreen..."); // Debug log
    if (document.exitFullscreen) {
        document.exitFullscreen().catch(err => console.error("Error exiting fullscreen:", err));
    } else if (document.webkitExitFullscreen) { /* Safari */
        document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) { /* IE11 */
        document.msExitFullscreen();
    }
}

/**
 * Handles fullscreen change events
 * @function handleFullscreenChange
 * @returns {void}
 */
function handleFullscreenChange() {
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
    console.log("Fullscreen change detected. Is fullscreen:", isFullscreen); // Debug log
    if (isFullscreen) {
        // Entered fullscreen
        if (selectedImages.length === 0) {
            // If no images are selected, exit fullscreen
            exitFullscreen();
            showMessage("No images selected. Please select at least one image.", 4000);
            return;
        }

        // Generate the display order based on randomization setting
        displayOrder = generateDisplayOrder(selectedImages.length);
        currentOrderIndex = 0;
        currentImageIndex = displayOrder[0] || 0;

        // Preload the first few images
        preloadImages(currentImageIndex, 5);

        // Display the first image immediately
        displayImage(currentImageIndex);

        // Start the slideshow
        startSlideshow();
        hideMenu(); // Ensure menu is hidden initially
    } else {
        // Exited fullscreen
        stopSlideshow();
        hideMenu(); // Ensure menu is hidden
        // Clear the preloaded images cache when exiting
        preloadedImages = {};
    }
}

/**
 * Shows the corner menu
 * @function showMenu
 * @returns {void}
 */
function showMenu() {
    clearTimeout(menuTimeout); // Clear any pending hide timeout
    cornerMenu.style.display = 'block';
}

/**
 * Hides the corner menu with a slight delay
 * @function hideMenu
 * @returns {void}
 */
function hideMenu() {
    // Hide slightly delayed to allow moving mouse from zone to menu
    menuTimeout = setTimeout(() => {
        cornerMenu.style.display = 'none';
    }, config.ui.menuHideDelay);
}

// Prevent mouse leaving menu from immediately hiding if re-entering quickly
cornerMenu.addEventListener('mouseenter', () => {
    clearTimeout(menuTimeout);
});


/**
 * Initial Setup
 */

/**
 * Initializes the application
 * @function initializeApp
 * @async
 * @returns {Promise&lt;void>}
 */
async function initializeApp() {
    // Apply configuration values to the DOM
    applyConfigToDOM();

    // Set initial background color variable
    bgColorInput.dispatchEvent(new Event('input'));

    // Initialize state variables
    currentImageIndex = 0;
    randomizeOrder = config.display.defaultRandomizeOrder;
    randomizeCheckbox.checked = config.display.defaultRandomizeOrder;

    // Set default duration
    durationInput.value = config.display.defaultDuration;

    // Set default background color
    bgColorInput.value = config.display.defaultBackgroundColor;

    // Initialize display order (will be regenerated when entering fullscreen)
    displayOrder = [];
    currentOrderIndex = 0;

    // Clear the display
    imageDisplay.src = ""; // Ensure image is blank initially outside fullscreen
    imageInfo.textContent = "";

    // Load images from the folder
    await loadImagesFromFolder();

    // Set up select all/deselect all buttons
    if (folderImages.length > 0) {
        showMessage(`Loaded ${folderImages.length} images from the images folder.`);
    }

    // Hide the loading overlay once everything is initialized
    hideLoadingOverlay();
}

/**
 * Event Listeners for Page Load
 */

// Run initialization when the DOM is ready
document.addEventListener('DOMContentLoaded', initializeApp);

// Ensure the loading overlay is hidden even if there are slow resources
window.addEventListener('load', () => {
    // If initialization is complete, this will have no effect
    // If not, it ensures the overlay is hidden once all resources are loaded
    setTimeout(hideLoadingOverlay, 500);
});
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-modules"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-compress-images.html">compress-images</a></div><div class="sidebar-section-children"><a href="module-config.html">config</a></div><div class="sidebar-section-children"><a href="module-config.html">config</a></div><div class="sidebar-section-children"><a href="module-download-sample-images.html">download-sample-images</a></div><div class="sidebar-section-children"><a href="module-main.html">main</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-namespaces"><div>Namespaces</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-config-config.display.html">display</a></div><div class="sidebar-section-children"><a href="module-config-config.images.html">images</a></div><div class="sidebar-section-children"><a href="module-config-config.placeholders.html">placeholders</a></div><div class="sidebar-section-children"><a href="module-config-config.ui.html">ui</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>